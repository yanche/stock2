
import IFactory from '../fac';
import * as utility from 'utility';
import * as dpm from '../../dpm';
import * as def from '../../def';
import * as bb from 'bluebird';

function facOfFac(ref: string): IFactory<string, number> {
    function dpid(target: string): string { return `${ref}_${target}` }

    return {
        make: (target: string) => dpm.getRawData(target)
            .then(raw => new def.DataPvd<number>({
                id: dpid(target),
                hasdef: ts => raw.rawmap.has(ts),
                gen: ts => bb.resolve(getRawVal(ref, raw.rawmap.get(ts))),
                maxTs: raw.rawarr[0]._ts,
                minTs: raw.rawarr[raw.rawarr.length - 1]._ts,
                remoteTs: (ts: number, n: number): number => {
                    //ts is in defined area
                    const idx = raw.rawmap.get(ts)._idx;
                    const tidx = idx + n;
                    if (tidx < 0 || tidx >= raw.rawarr.length) return null;
                    else return raw.rawarr[tidx]._ts;
                },
                weakdepts: [target]
            })),
        validate: utility.validate.nonEmptyStr,
        dpid: dpid,
        weakDepts: (target: string) => [target]
    }
}

function getRawVal(ref: string, data: dpm.RawDataSlice): number {
    switch (ref) {
        case 's': return data.s;
        case 'e': return data.e;
        case 'l': return data.l;
        case 'h': return data.h;
        case 'v': return data.v;
        case 'ex': return data.ex;
        case 'nr': return data.nr;
        case 'mv': return data.mv;
        default: throw new Error(`unknown ref of raw-data: ${ref}`);
    }
}

const start = facOfFac('s');
const end = facOfFac('e');
const high = facOfFac('h');
const low = facOfFac('l');
const ex = facOfFac('ex');
const vol = facOfFac('v');
const marketvalue = facOfFac('mv');
const netrate = facOfFac('nr');

export {start, end, high, low, ex, vol, marketvalue, netrate}
