
import IFactory from '../fac';
import * as bb from 'bluebird';
import * as def from '../../def';
import * as utility from 'utility';
import * as literal from '../../literal';

function dpid(pack: EWAFacPack): string { return `EMA_${pack.N}_${pack.W}_${literal.dpid(pack.dp)}`; }

interface EWAFacPack {
    N: number,
    W: number,
    dp: def.DataPvd<number> | literal.LiteralDP
}

const emaFac: IFactory<EWAFacPack, number> = {
    make: (pack: EWAFacPack) => {
        return literal.resolve(pack.dp)
            .then((dp: def.DataPvd<number>) => {
                const emadp = new def.StoredDataPvd<number>({
                    id: dpid(pack),
                    maxTs: dp.maxTs,
                    minTs: dp.minTs,
                    hasdef: dp.hasDef_core,
                    gen: (ts: number): bb<number> => {
                        if (ts === dp.minTs) return dp.get(ts);
                        else return bb.all([dp.get(ts), emadp.get(dp.remoteTs(ts, -1))])
                            .then(data => data[1] * (pack.N - pack.W + 1) / (pack.N + 1) + data[0] * pack.W / (pack.N + 1));
                    },
                    remoteTs: dp.remoteTs_core,
                    weakdepts: dp.weakdepts
                });
                return emadp;
            });
    },
    validate: (pack: EWAFacPack): boolean => utility.validate.posInt(pack.N) && utility.validate.posInt(pack.W) && literal.validate(pack.dp) && (pack.N + 1) >= pack.W,
    dpid: dpid,
    weakDepts: (pack: EWAFacPack): Array<string> => literal.weakDepts(pack.dp)
};

export default emaFac;
