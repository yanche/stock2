
import IFactory from '../fac';
import * as bb from 'bluebird';
import * as def from '../../def';
import * as utility from 'utility';
import * as literal from '../../literal';
import * as facutil from '../facutil';

function dpid(pack: KDJFacPack): string { return `KDJ_${pack.N}_${pack.Nk}_${pack.Nd}_${pack.target}`; }

interface KDJFacPack {
    N: number,
    Nk: number,
    Nd: number,
    target: string
}

interface KDJRet {
    k: number,
    d: number,
    j: number
}

const kdjFac: IFactory<KDJFacPack, KDJRet> = {
    make: (pack: KDJFacPack) => {
        return bb.all([
            literal.resolve({ type: 'r.end', pack: pack.target }),
            literal.resolve({ type: 'r.high', pack: pack.target }),
            literal.resolve({ type: 'r.low', pack: pack.target }),
        ])
            .then(dps => {
                const epvd = <def.DataPvd<number>>dps[0], hpvd = <def.DataPvd<number>>dps[1], lpvd = <def.DataPvd<number>>dps[2];
                return new def.DataPvd<number>({
                    id: `RSV_${pack.N}`,
                    hasdef: epvd.hasDef_core,
                    gen: (ts: number): bb<number> => {
                        const bts = epvd.remoteTs(ts, -pack.N + 1);
                        return bb.all([epvd.get(ts), hpvd.period(bts, ts), lpvd.period(bts, ts)])
                            .then(data => {
                                const cur = data[0], H = utility.array.max(data[1], x => x.val).val, L = utility.array.min(data[2], x => x.val).val;
                                return H === L ? 50 : ((cur - L) / (H - L) * 100);
                            });
                    },
                    minTs: epvd.remoteTs(epvd.minTs, pack.N - 1) || facutil.dateTsOffset(epvd.maxTs, 1),
                    maxTs: epvd.maxTs,
                    remoteTs: epvd.remoteTs_core,
                    weakdepts: epvd.weakdepts
                })
            })
            .then(rsvpvd => literal.resolve({ type: 'b.ema', pack: { N: pack.Nk - 1, W: 1, dp: rsvpvd } }))
            .then(kpvd => bb.all([kpvd, literal.resolve({ type: 'b.ema', pack: { N: pack.Nd - 1, W: 1, dp: kpvd } })]))
            .then(data => {
                const kpvd = <def.DataPvd<number>>data[0], dpvd = <def.DataPvd<number>>data[1];
                return new def.StoredDataPvd<KDJRet>({
                    id: dpid(pack),
                    hasdef: dpvd.hasDef_core,
                    gen: (ts: number): bb<KDJRet> => {
                        return bb.all([kpvd.get(ts), dpvd.get(ts)])
                            .then(data => {
                                const k = data[0], d = data[1];
                                return {
                                    k: k,
                                    d: d,
                                    j: k * 3 - d * 2
                                };
                            })
                    },
                    remoteTs: dpvd.remoteTs_core,
                    minTs: dpvd.minTs,
                    maxTs: dpvd.maxTs,
                    weakdepts: [pack.target]
                });
            });
    },
    validate: (pack: KDJFacPack): boolean => utility.validate.posInt(pack.N) && utility.validate.posInt(pack.Nk) && utility.validate.posInt(pack.Nd) && utility.validate.nonEmptyStr(pack.target),
    dpid: dpid,
    weakDepts: (pack: KDJFacPack): Array<string> => [pack.target]
};

export default kdjFac;
