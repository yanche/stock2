
import IFactory from './fac';
import * as utility from 'utility';
import * as literal from '../literal';
import * as def from '../def';
import * as bb from 'bluebird';

export interface PackBase {
    dp: def.DataPvd<any> | literal.LiteralDP,
    [name: string]: any
}

export function dpTransform<P extends PackBase, T>(options: {
    prefix: string,
    inputlist: Array<{
        name: string,
        validate?: (val: any) => boolean,
        tostr?: (val: any) => string
    }>,
    gen: (pack: P, dp: def.DataPvd<T>, ts: number) => bb<T>,
    mmts?: (pack: P, dp: def.DataPvd<T>) => { minTs: number, maxTs: number },
    stored?: boolean
}): IFactory<P, T> {
    if (!utility.validate.nonEmptyStr(options.prefix) || options.inputlist.some(item => !utility.validate.nonEmptyStr(item.name)))
        throw new Error(`bad input for dpTransform`);
    const inputlist = options.inputlist.map(item => { return { name: item.name, validate: item.validate || utility.validate.alwaysTrue, tostr: item.tostr || utility.toStr }; });
    function dpid(pack: P): string {
        return [options.prefix, literal.dpid(pack.dp)].concat(inputlist.map(item => item.tostr(pack[item.name]))).join('_');
    }
    return {
        dpid: dpid,
        make: (pack: P): bb<def.DataPvd<T>> => {
            return literal.resolve(pack.dp).then(dp => {
                const mmret = options.mmts == null ? { minTs: dp.minTs, maxTs: dp.maxTs } : options.mmts(pack, dp);
                return new (options.stored ? def.StoredDataPvd : def.DataPvd)<T>({
                    id: dpid(pack),
                    hasdef: (ts: number): boolean => dp.hasDef(ts),
                    gen: (ts: number): bb<T> => options.gen(pack, dp, ts),
                    remoteTs: dp.remoteTs_core,
                    minTs: mmret.minTs,
                    maxTs: mmret.maxTs,
                    weakdepts: dp.weakdepts
                });
            })
        },
        validate: (pack: P): boolean => literal.validate(pack.dp) && inputlist.every(item => item.validate(pack[item.name])),
        weakDepts: (pack: P): Array<string> => literal.weakDepts(pack.dp)
    }
}
