
import IFactory from './fac';
import * as utility from 'utility';
import * as literal from '../literal';
import * as def from '../def';
import * as bb from 'bluebird';

export function dateTsOffset(datets: number, days: number): number {
    return datets + days;
}

export interface PackBase<TdpIn> {
    dp: def.DataPvd<TdpIn> | literal.LiteralDP,
    [name: string]: any
}

export function dpTransform<P extends PackBase<TdpIn>, TdpIn, TdpOut>(options: {
    prefix: string,
    inputlist: Array<{
        name: string,
        validate?: (val: any) => boolean,
        tostr?: (val: any) => string
    }>,
    gen: (pack: P, dp: def.DataPvd<TdpIn>, ts: number, selfdp: def.DataPvd<TdpOut>) => bb<TdpOut>,
    mmts?: (pack: P, dp: def.DataPvd<TdpIn>) => { minTs: number, maxTs: number },
    stored?: boolean
}): IFactory<P, TdpOut> {
    if (!utility.validate.nonEmptyStr(options.prefix) || options.inputlist.some(item => !utility.validate.nonEmptyStr(item.name)))
        throw new Error(`bad input for dpTransform`);
    const inputlist = options.inputlist.map(item => { return { name: item.name, validate: item.validate || utility.validate.alwaysTrue, tostr: item.tostr || utility.toStr }; });
    function dpid(pack: P): string {
        return [options.prefix, literal.dpid(pack.dp)].concat(inputlist.map(item => item.tostr(pack[item.name]))).join('_');
    }
    return {
        dpid: dpid,
        make: (pack: P): bb<def.DataPvd<TdpOut>> => {
            return literal.resolve(pack.dp).then((dp: def.DataPvd<TdpIn>) => {
                const mmret = options.mmts == null ? { minTs: dp.minTs, maxTs: dp.maxTs } : options.mmts(pack, dp);
                const retdp = new (options.stored ? def.StoredDataPvd : def.DataPvd)<TdpOut>({
                    id: dpid(pack),
                    hasdef: dp.hasDef_core,
                    gen: (ts: number): bb<TdpOut> => options.gen(pack, dp, ts, retdp),
                    remoteTs: dp.remoteTs_core,
                    minTs: mmret.minTs,
                    maxTs: mmret.maxTs,
                    weakdepts: dp.weakdepts
                });
                return retdp;
            })
        },
        validate: (pack: P): boolean => literal.validate(pack.dp) && inputlist.every(item => item.validate(pack[item.name])),
        weakDepts: (pack: P): Array<string> => literal.weakDepts(pack.dp)
    }
}
