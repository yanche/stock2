
import IFactory from '../fac';
import * as def from '../../def';
import * as utility from 'utility';
import * as facutil from '../facutil';
import * as bb from 'bluebird';

interface OffsetFacPack extends facutil.TransformPackBase<any> {
    N: number
}

interface OffsetRet {
    val: any,
    ts: number
}

function mmts(pack: OffsetFacPack, dp: def.DataPvd<any>) {
    if (pack.N === 0) return { minTs: dp.minTs, maxTs: dp.maxTs };
    else if (pack.N > 0) return { minTs: dp.minTs, maxTs: dp.backwardTs(dp.maxTs, pack.N) || facutil.dateTsOffset(dp.minTs, -1) };
    else return { maxTs: dp.maxTs, minTs: dp.forwardTs(dp.minTs, -pack.N) || facutil.dateTsOffset(dp.maxTs, 1) };
}

// N>0, future value, N<0 past value
const offsetFac: IFactory<OffsetFacPack, any> = facutil.dpTransform<OffsetFacPack, any, OffsetRet>({
    prefix: 'OFFSET',
    inputlist: [{ name: 'N', validate: utility.validate.isInt }],
    gen: (pack: OffsetFacPack, dp: def.DataPvd<any>, ts: number): OffsetRet => {
        const bts = pack.N > 0 ? dp.forwardTs(ts, pack.N) : dp.backwardTs(ts, -pack.N);
        return { val: dp.get(bts), ts: bts };
    },
    mmts: mmts
});

const offsetVFac: IFactory<OffsetFacPack, any> = facutil.dpTransform<OffsetFacPack, any, any>({
    prefix: 'OFFSETV',
    inputlist: [{ name: 'N', validate: utility.validate.isInt }],
    gen: (pack: OffsetFacPack, dp: def.DataPvd<any>, ts: number): bb<any> => {
        return dp.get(pack.N > 0 ? dp.forwardTs(ts, pack.N) : dp.backwardTs(ts, -pack.N));
    },
    mmts: mmts
});

export { offsetFac, offsetVFac };
