
import * as def from './def';
import * as bb from 'bluebird';
import factories from './factory';
import * as dpm from './dpm';
import * as mods from 'mods';

var dpToCache = new Set<string>();
dpToCache.add('b.ma').add('b.boll').add('b.ema').add('b.kdj').add('b.macd').add('b.rsi').add('r.amp').add('r.grow').add('u.mktdays');

function dpCacheable(type: string): boolean {
    return dpToCache.has(type);
}

export interface LiteralDP {
    type: string,
    pack: any
}

export function resolve(ldp: LiteralDP | def.DataPvd<any>): bb<def.DataPvd<any>> {
    if (ldp instanceof def.DataPvd)
        return bb.resolve(ldp);
    else {
        const type = ldp.type, pack = ldp.pack;
        const factory = factories.get(type);
        if (factory == null) return bb.reject(new Error(`unknown dp type: ${type}`));
        if (!factory.validate(pack)) return bb.reject(new Error(`bad input for dp type, ${type}, ${pack}`));
        if (dpCacheable(type)) {
            const weakdptgts = factory.weakDepts(pack);
            if (weakdptgts.length !== 1) {
                console.warn(`for cacheable dp, the dependant target is not 1, ${type}, ${weakdptgts.length}`);
                return factory.make(pack); //no cache then
            }
            else {
                return dpm.getDPCache(weakdptgts[0])
                    .then(dpcache => {
                        const dpid = factory.dpid(pack);
                        var dphub = dpcache.get(dpid);
                        if (dphub == null) {
                            dphub = new mods.Hub(() => factory.make(pack));
                            dpcache.set(dpid, dphub);
                        }
                        return dphub.get();
                    });
            }
        }
        else return factory.make(pack);
    }
}
