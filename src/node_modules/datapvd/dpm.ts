
import * as mods from 'mods';
import * as utility from 'utility';
import * as config from 'config';
import * as bb from 'bluebird';
import * as def from './def';
import * as datadef from 'datadef';
import * as datasrc from 'datasrc';

interface RawDataSlice2 extends datadef.RawDataSlice {
    _ts: number;
    _idx: number;
}

export function getRawData(target: string): bb<RawDataAggr> {
    return <bb<RawDataAggr>>retrieve(target).rawHub.get();
}

export function cachedTargets(): Array<string> {
    return srcCache.map(c => c.target);
}

/**
 * targets: target list to remove
 */
export function clearCache(targets: Array<string>): void {
    srcCache = targets == null ? [] : srcCache.filter(c => targets.every(t => t !== c.target));
}

export function getDPCache(target: string): bb<Map<string, mods.Hub<def.DataPvd<any>>>> {
    return getRawData(target)
        .then(r => r.dpCache);
}

interface RawDataAggr {
    rawarr: Array<RawDataSlice2>, //at least one
    rawmap: Map<number, RawDataSlice2>,
    dpCache: Map<string, mods.Hub<def.DataPvd<any>>>
}

interface CachedItem {
    target: string,
    rawHub: mods.Hub<RawDataAggr>,
    permanent: boolean,
    lastAccessTs: number
}
let srcCache = new Array<CachedItem>();

function genRawDataHub(target: string): mods.Hub<RawDataAggr> {
    return new mods.Hub<RawDataAggr>(() => {
        let fname = `${target}.json`;
        return datasrc.mine.targetData.get2(target)
            .then(rawdata => {
                if (rawdata == null) throw new Error(`failed to load raw-data from ${config.useLocalRaw ? 'local folder' : 'azure storage'}`);
                let minTs = utility.date.dateKey2DateTs(rawdata.minDay), maxTs = utility.date.dateKey2DateTs(rawdata.maxDay);
                let rawarr = new Array<RawDataSlice2>(), datamap = rawdata.data, mintshit = false, maxtshit = false, rawmap = new Map<number, RawDataSlice2>();
                for (let d in datamap) {
                    let ds = <RawDataSlice2>datamap[d], ts = utility.date.dateKey2DateTs(d);
                    if (ts < minTs || ts > maxTs) throw new Error(`data ts exceeds the range of min-max ts, ${d}, ${rawdata.minDay}, ${rawdata.maxDay}`);
                    if (ts === minTs) mintshit = true;
                    if (ts === maxTs) maxtshit = true;
                    ds._ts = ts;
                    rawarr.push(ds);
                    rawmap.set(ts, ds);
                }
                if (!mintshit) throw new Error(`no data found for minTs, ${rawdata.minDay}`);
                if (!maxtshit) throw new Error(`no data found for maxTs, ${rawdata.maxDay}`);
                rawarr.sort((v1, v2) => v1._ts - v2._ts);
                for (let i = 0; i < rawarr.length; ++i) rawarr[i]._idx = i;
                return { rawarr: rawarr, rawmap: rawmap, dpCache: new Map<string, mods.Hub<def.DataPvd<any>>>() };
            });
    }, config.rawDataExpiryInMS);
}

function retrieve(target: string): CachedItem {
    let incache = findCache(target);
    if (incache != null) {
        incache.lastAccessTs = new Date().getTime();
        return incache;
    }
    else {
        let src: CachedItem = { target: target, rawHub: genRawDataHub(target), lastAccessTs: new Date().getTime(), permanent: targetPermanentCached(target) };
        if (src.permanent || weakCacheCount() < config.maxRawDataCached) {
            srcCache.push(src);
        }
        else {
            let withMinTs = utility.array.min(srcCache.filter(c => !c.permanent), c => c.lastAccessTs);
            srcCache = srcCache.filter(c => c !== withMinTs);
            srcCache.push(src);
            console.log(`${withMinTs.target} removed from dpm cache, now: ${srcCache.length} left`);
        }
        return src;
    }
}

function findCache(target: string): CachedItem {
    return utility.array.findFirst(srcCache, x => x.target === target, null);
}

function weakCacheCount() {
    return utility.array.sum(srcCache, c => c.permanent ? 0 : 1);
};

function targetPermanentCached(target: string): boolean {
    let t = target.toUpperCase();
    return config.maintainIdx.some(s => t === s);
};
