
import * as mods from 'mods';
import * as utility from 'utility';
import * as config from 'config';
import * as path from 'path';
import * as filestorage from 'filestorage';
import * as bb from 'bluebird';
import * as def from './def';

export function getRawData(target: string): bb<RawDataAggr> {
    return <bb<RawDataAggr>>retrieve(target).rawHub.get();
}

export function cachedTargets(): Array<string> {
    return srcCache.map(c => c.target);
}

/**
 * targets: target list to remove
 */
export function clearCache(targets: Array<string>): void {
    srcCache = targets == null ? [] : srcCache.filter(c => targets.every(t => t !== c.target));
}

export function getDPCache(target: string): bb<Map<string, mods.Hub<def.DataPvd<any>>>> {
    return getRawData(target)
        .then(r => r.dpCache);
}

export interface RawDataSlice {
    s: number,
    e: number,
    h: number,
    l: number,
    ex: number,
    nr: number,
    mv: number,
    v: number,
    _ts: number,
    _idx: number
}

interface RawData {
    data: { [key: string]: RawDataSlice },
    minDay: string,
    maxDay: string
}

interface RawDataAggr {
    rawarr: Array<RawDataSlice>, //at least one
    rawmap: Map<number, RawDataSlice>,
    dpCache: Map<string, mods.Hub<def.DataPvd<any>>>
}

interface CachedItem {
    target: string,
    rawHub: mods.Hub<RawDataAggr>,
    permanent: boolean,
    lastAccessTs: number
}
var srcCache = new Array<CachedItem>();

function genRawDataHub(target: string): mods.Hub<RawDataAggr> {
    return new mods.Hub<RawDataAggr>(() => {
        var fname = `${target}.json`;
        return (config.useLocalRaw ? utility.file.loadJsonFile<RawData>(path.join(config.rawDataFolder, fname)) : filestorage.azure.downloadJson2<RawData>(config.azurestorage.container.raw, fname))
            .then(rawdata => {
                if (rawdata == null) throw new Error(`failed to load raw-data from ${config.useLocalRaw ? 'local folder' : 'azure storage'}`);
                var minTs = utility.date.dateKey2DateTs(rawdata.minDay), maxTs = utility.date.dateKey2DateTs(rawdata.maxDay);
                var rawarr = new Array<RawDataSlice>(), datamap = rawdata.data, mintshit = false, maxtshit = false, rawmap = new Map<number, RawDataSlice>();
                for (var d in datamap) {
                    var ds = datamap[d], ts = utility.date.dateKey2DateTs(d);
                    if (ts < minTs || ts > maxTs) throw new Error(`data ts exceeds the range of min-max ts, ${d}, ${rawdata.minDay}, ${rawdata.maxDay}`);
                    if (ts === minTs) mintshit = true;
                    if (ts === maxTs) maxtshit = true;
                    ds._ts = ts;
                    rawarr.push(ds);
                    rawmap.set(ts, ds);
                }
                if (!mintshit) throw new Error(`no data found for minTs, ${rawdata.minDay}`);
                if (!maxtshit) throw new Error(`no data found for maxTs, ${rawdata.maxDay}`);
                rawarr.sort((v1, v2) => v1._ts - v2._ts);
                for (var i = 0; i < rawarr.length; ++i) rawarr[i]._idx = i;
                return { rawarr: rawarr, rawmap: rawmap, dpCache: new Map<string, mods.Hub<def.DataPvd<any>>>() };
            });
    }, config.rawDataExpiryInMS);
}

function retrieve(target: string): CachedItem {
    var incache = findCache(target);
    if (incache != null) {
        incache.lastAccessTs = new Date().getTime();
        return incache;
    }
    else {
        var src: CachedItem = { target: target, rawHub: genRawDataHub(target), lastAccessTs: new Date().getTime(), permanent: targetPermanentCached(target) };
        if (src.permanent || weakCacheCount() < config.maxRawDataCached) {
            srcCache.push(src);
        }
        else {
            var withMinTs = utility.array.min(srcCache.filter(c => !c.permanent), c => c.lastAccessTs);
            srcCache = srcCache.filter(c => c !== withMinTs);
            srcCache.push(src);
            console.log(`${withMinTs.target} removed from dpm cache, now: ${srcCache.length} left`);
        }
        return src;
    }
}

function findCache(target: string): CachedItem {
    return utility.array.findFirst(srcCache, x => x.target === target, null);
}

function weakCacheCount() {
    return utility.array.sum(srcCache, c => c.permanent ? 0 : 1);
};

function targetPermanentCached(target: string): boolean {
    var t = target.toUpperCase();
    return config.maintainIdx.some(s => t === s);
};
