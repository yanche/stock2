
import * as co from 'co';
import * as bb from 'bluebird';
import * as utility from 'utility';
import * as mods from 'mods';

interface DataPvdInput<T> {
    id: string,
    minTs: number,
    maxTs: number,
    hasdef: (ts: number) => boolean,
    gen: (ts: number) => bb<T>,
    remoteTs: (ts: number, n: number) => number,
    weakdepts: Array<string>
}

export class DataPvd<T> {
    protected _id: string;
    protected _mints: number;
    protected _maxts: number;
    protected _hasdef: (ts: number) => boolean;
    protected _gen: (ts: number) => bb<T>;
    protected _remoteTs: (ts: number, n: number) => number;
    protected _weakdepts: Array<string>;

    constructor(pack: DataPvdInput<T>) {
        if (!utility.validate.nonNegNum(pack.minTs, true) || !utility.validate.nonNegNum(pack.maxTs, true))
            throw new Error(`minTs or maxTs invalid, ${pack.minTs}, ${pack.maxTs}`);
        this._id = pack.id;
        this._maxts = pack.maxTs;
        this._mints = pack.minTs;
        //when _hasdef is called, no 'this' pointer will be passed
        this._hasdef = pack.hasdef;
        //when _gen is called, no 'this' pointer will be passed
        this._gen = pack.gen;
        //when _remoteTs is called, no 'this' pointer will be passed
        this._remoteTs = pack.remoteTs;
        this._weakdepts = pack.weakdepts;
    }

    get minTs(): number { return this._mints; }
    get maxTs(): number { return this._maxts; }
    get id(): string { return this._id; }
    get weakdepts(): Array<string> { return this._weakdepts; }
    get remoteTs_core(): (ts: number, n: number) => number { return this._remoteTs; }
    get hasDef_core(): (ts: number) => boolean { return this._hasdef; }
    get gen_core(): (ts: number) => bb<T> { return this._gen; }
    hasDef(ts: number): boolean {
        return ts >= this._mints && ts <= this._maxts && this._hasdef.call(null, ts);
    }
    remoteTs(ts: number, n: number): number {
        const retts = this._remoteTs.call(null, ts, n);
        return (retts != null && retts >= this._mints && retts <= this._maxts) ? retts : null;
    }
    periodTs(mints: number, maxts: number): Array<number> {
        if (this.hasDef(mints) && this.hasDef(maxts)) {
            var ts = mints, ret = new Array<number>();
            while (true) {
                ret.push(ts);
                if (ts === maxts) return ret;
                else ts = this.remoteTs(ts, 1);
            }
        }
        else throw new Error(`input for periodTs is out of defined area, ${mints}, ${maxts}`);
    }
    period(mints: number, maxts: number): bb<Array<{ val: T, ts: number }>> {
        return bb.map(this.periodTs(mints, maxts), ts => (<bb<T>>this._gen.call(null, ts)).then(val => { return { ts: ts, val: val }; }));
    }
    get(ts: number): bb<T> {
        if (this.hasDef(ts)) return this._gen.call(null, ts);
        else throw new Error(`input for get is out of defined area, ${ts}`);
    }
    cached(ts: number): boolean { return false; }
}

export class StoredDataPvd<T> extends DataPvd<T> {
    protected _cache: Map<number, mods.Hub<T> | T>;
    constructor(pack: DataPvdInput<T>) {
        super(pack);
        this._cache = new Map<number, mods.Hub<T> | T>();
    }
    get(ts: number): bb<T> {
        if (!this.hasDef(ts)) throw new Error(`input for get is out of defined area, ${ts}`);
        if (this._cache.has(ts)) {
            // console.log('data from cache (StoredDataPvd)');
            const incache = this._cache.get(ts);
            if (incache instanceof mods.Hub) return <bb<T>>incache.get();
            else return bb.resolve(incache);
        }
        else {
            const hub = new mods.Hub<T>(() => (<bb<T>>this._gen.call(null, ts)).then(data => { this._cache.set(ts, data); return data; }));
            this._cache.set(ts, hub);
            return <bb<T>>hub.get();
        }
    }
    cached(ts: number): boolean { return this._cache.has(ts); }
}
