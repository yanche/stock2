
import * as http from 'http';
import * as https from 'https';
import * as bb from 'bluebird';
import * as config from 'config';
import * as _ from 'lodash';
import * as validate from './validate';

export interface WebReqOptions extends https.RequestOptions {
    _retrying?: boolean;
    retry?: number;
    timeout?: number;
}

export interface WebReqReturn {
    statusCode: number,
    headers: { [key: string]: string },
    data: Buffer
}

export function webreq(options: WebReqOptions, body?: Buffer | Object | Array<any> | string, secure?: boolean) {
    return new bb<WebReqReturn>((resolve, reject) => {
        if (config.useFiddler && !options._retrying) {
            options.path = (secure ? 'https://' : 'http://') + options.host + (options.port ? (':' + options.port) : '') + options.path;
            if (options.headers == null)
                options.headers = {};
            options.headers['host'] = options.host;
            options.host = '127.0.0.1';
            options.port = 8888;
        }
        var req = http.request(options, (res: http.IncomingMessage) => {
            var bufs = new Array<Buffer>();
            res.on('data', (d: Buffer) => {
                bufs.push(d);
            }).on('end', () => {
                resolve({
                    statusCode: res.statusCode,
                    headers: res.headers,
                    data: Buffer.concat(bufs)
                });
            });
        });
        if (options.timeout != null) {
            req.setTimeout(options.timeout, () => {
                var err = new Error(`http${secure ? 's' : ''} call timeout`);
                //err.code = 'ETIMEDOUT';
                reject(err);
            });
        }
        if (body != null && (typeof body === 'object' || Array.isArray(body))) {
            req.setHeader('Content-Type', 'application/json');
            req.end(JSON.stringify(body));
        }
        else if (typeof body === 'string') {
            req.setHeader('Content-Type', 'text/plain');
            req.end(body);
        }
        else
            req.end(body); //null or Buffer
        req.on('error', (err: Error) => {
            if (options.retry == null || options.retry <= 0)
                reject(err);
            else {
                webreq(<WebReqOptions>_.extend({}, options, { retry: options.retry - 1, _retrying: true }), body, secure)
                    .then(resolve, reject);
            }
        });
    });
};

export class HttpPack {
    private _reqheaders: Map<string, string>;
    private _headers: Map<string, string>;
    private _bodybuf: Buffer;
    private _status: number;

    getReqHeader(name: string): string {
        return this._reqheaders.get(name.toLowerCase());
    }
    setResHeader(name: string, value: string): this {
        this._headers.set(name, value);
        return this;
    }
    get method(): string { return this.getReqHeader('method'); };
    get reqbody(): any { return {}; }
    set body(value: Object | string | Buffer) {
        if (this._bodybuf != null) throw new Error('http response body has already been set');
        else if (value == null) throw new Error('does not accept null input');
        else {
            var bodybuf: Buffer = null, type = '';
            if (validate.isObj(value)) {
                bodybuf = new Buffer(JSON.stringify(value), 'utf8');
                type = 'application/json; charset=utf-8';
            }
            else if (validate.isStr(value)) {
                bodybuf = new Buffer(value);
                type = 'text/plain';
            }
            else {
                bodybuf = <Buffer>value;
                type = '';
            }
            this._bodybuf = bodybuf;
            this._headers.set('Content-Type', type);
        }
    }
    set status(value: number) {
        this._status = value;
    }
    constructor() {
        this._reqheaders = new Map<string, string>();
        this._headers = new Map<string, string>();
        this._status = null;
    }
}
