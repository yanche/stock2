
import * as datasrc from 'datasrc';
import * as bb from 'bluebird';
import * as utility from 'utility';
import Action from '../action';
import * as filestorage from 'filestorage';
import * as config from 'config';
import * as dclient from '../../dclient';
import * as wmraw from './raw';
import * as datapvd from 'datapvd';

interface WmMergeInput {
    target: string;
    wmcloudRawTaskId: string;
}

interface WmMergeOutput {
    drop?: filestorage.common.FileStorage,
    merge?: boolean,
    ratio?: number,
    delta?: { maxDay: string, minDay: string },
    origin?: { maxDay: string, minDay: string },
    nodata?: boolean
}

const wmcloudAction = new Action({
    refine: (raw: WmMergeInput): WmMergeInput => { return raw; },
    validate: (pack: WmMergeInput): boolean => {
        return utility.validate.isStr(pack.target) && pack.target.length > 0 && utility.validate.isStr(pack.wmcloudRawTaskId) && pack.wmcloudRawTaskId.length > 0;
    },
    resolve: (pack: WmMergeInput): bb<WmMergeOutput> => {
        return bb.resolve()
            .then(() => dclient.task.get({ _id: pack.wmcloudRawTaskId }, { quickview: 1 }))
            .then(task => {
                const qv = <wmraw.WmRawOutput>task.quickview;
                if (qv.nodata) return { nodata: true };
                else if (qv.drop != null || qv.rawdata != null) {
                    return (qv.rawdata != null ? bb.resolve(qv.rawdata) : filestorage.common.getJson<wmraw.WmRawOutput_data>(qv.drop).then(delta => {
                        if (delta == null) throw new Error(`failed to download delta, wmcloud-raw task id: ${pack.wmcloudRawTaskId}`);
                        return delta;
                    }))
                        .then((delta: wmraw.WmRawOutput_data) => {
                            if (delta.maxDayTs == null || delta.minDayTs == null || delta.data == null) throw new Error(`invalid delta: ${JSON.stringify(delta)}`);
                            return filestorage.azure.downloadJson2(config.azurestorage.container.raw, pack.target + '.json')
                                .then((rjson: datapvd.RawData) => {
                                    if (rjson == null) throw new Error(`failed to load raw stock data: ${pack.target}`);
                                    if (utility.date.dateKey2DateTs(rjson.maxDay) >= delta.minDayTs) throw new Error(`${pack.target}, ${pack.wmcloudRawTaskId}, overlap, ${rjson.maxDay}, ${utility.date.dateFormat(utility.date.dateTs2MsTs(delta.minDayTs))}`);
                                    const ratio = rjson.data[rjson.maxDay].e / delta.data[delta.minDayTs].p;
                                    if (isNaN(ratio) || !isFinite(ratio) || ratio <= 0) throw new Error(`bad ratio: ${ratio}`);
                                    for (const _d in delta.data) {
                                        const d = Number(_d);
                                        const daydata = delta.data[d];
                                        rjson.data[utility.date.dateTs2DateKey(d)] = {
                                            s: utility.num.frac(daydata.s * ratio, 4),
                                            e: utility.num.frac(daydata.e * ratio, 4),
                                            h: utility.num.frac(daydata.h * ratio, 4),
                                            l: utility.num.frac(daydata.l * ratio, 4),
                                            ex: daydata.ex,
                                            v: daydata.v,
                                            mv: daydata.mv,
                                            nr: daydata.nr
                                        };
                                    }
                                    rjson.maxDay = utility.date.dateTs2DateKey(delta.maxDayTs);
                                    return filestorage.azure.upload(new Buffer(JSON.stringify(rjson)), pack.target + '.json', null, config.azurestorage.container.raw)
                                        .then(drop => {
                                            return <WmMergeOutput>{
                                                drop: drop,
                                                merge: true,
                                                delta: {
                                                    maxDay: utility.date.dateTs2DateKey(delta.maxDayTs),
                                                    minDay: utility.date.dateTs2DateKey(delta.minDayTs)
                                                },
                                                origin: {
                                                    maxDay: rjson.maxDay,
                                                    minDay: rjson.minDay
                                                },
                                                ratio: ratio
                                            };
                                        });
                                });
                        });
                }
                else throw new Error(`unrecognized quickview format: ${JSON.stringify(qv)}`);
            });
    }
});
