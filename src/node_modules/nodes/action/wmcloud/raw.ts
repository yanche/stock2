
import * as datasrc from 'datasrc';
import * as bb from 'bluebird';
import * as utility from 'utility';
import Action from '../action';
import * as filestorage from 'filestorage';
import * as config from 'config';

// date is day-ts if it's a number
function inputDateConv(date: Date | number): Date {
    if (date instanceof Date) return date;
    else return new Date(utility.date.dateTs2MsTs(date));
}

export interface WmRawInput {
    target: string;
    isIndex: boolean;
    start?: Date | number;
    end?: Date | number;
}

interface WmRawRefinedInput {
    target: string;
    isIndex: boolean;
    start: Date;
    end: Date;
}

export interface WmRawOutput_data {
    maxDayTs: number,
    minDayTs: number,
    data: { [key: number]: dailyStockData }
}

export interface WmRawOutput {
    nodata?: boolean;
    rawdata?: WmRawOutput_data;
    drop?: filestorage.common.FileStorage
}

interface dailyStockData {
    d: number; //day-ts
    s: number;
    e: number;
    h: number;
    l: number;
    ex?: number;
    v: number;
    mv?: number;
    nr?: number;
    p?: number;
}

export const action = new Action({
    refine: (raw: WmRawInput): WmRawRefinedInput => {
        return {
            target: (raw.target || '').trim(),
            isIndex: raw.isIndex,
            start: raw.start == null ? new Date(Date.UTC(1991, 0, 1)) : inputDateConv(raw.start),
            end: raw.end == null ? utility.date.nowUTCDate() : inputDateConv(raw.end)
        }
    },
    validate: (pack: WmRawRefinedInput): boolean => {
        return utility.validate.isStr(pack.target) && pack.target.length > 0 && utility.validate.isBool(pack.isIndex)
            && utility.validate.isDate(pack.start) && utility.validate.isDate(pack.end) && !isNaN(pack.start.getTime()) && !isNaN(pack.end.getTime()) && pack.start.getTime() <= pack.end.getTime();
    },
    resolve: (pack: WmRawRefinedInput): bb<WmRawOutput> => {
        return pack.isIndex ? resolveIndex(pack) : resolveStock(pack);
    }
});

const stockFields = ['openPrice', 'closePrice', 'highestPrice', 'lowestPrice', 'turnoverRate', 'preClosePrice', 'turnoverValue', 'negMarketValue', 'marketValue', 'tradeDate', 'isOpen', 'accumAdjFactor'];
const indexFields = ['openIndex', 'closeIndex', 'highestIndex', 'lowestIndex', 'preCloseIndex', 'turnoverValue', 'tradeDate'];

function resolveIndex(pack: WmRawRefinedInput): bb<WmRawOutput> {
    return bb.resolve()
        .then(() => datasrc.wm.market.getMktIdxd(new datasrc.wm.GetMktIdxdParams(pack.target, pack.start, pack.end, indexFields)))
        .then(data => {
            if (data.length === 0) return { nodata: true };
            let prevdts: number = null;
            const vmap: { [key: number]: dailyStockData } = {};
            for (let d of data) {
                const dayts = utility.date.msTs2DateTs(parseDateStr(d.tradeDate));
                if (prevdts != null && dayts <= prevdts) throw new Error(`data not sorted by tradeDate: ${utility.date.dateFormat(utility.date.dateTs2MsTs(prevdts))} - ${utility.date.dateFormat(utility.date.dateTs2MsTs(dayts))}`);
                const v = d.turnoverValue / 100000000;
                const tsdata: dailyStockData = {
                    d: dayts,
                    s: utility.num.frac(d.openIndex, 4),
                    e: utility.num.frac(d.closeIndex, 4),
                    h: utility.num.frac(d.highestIndex, 4),
                    l: utility.num.frac(d.lowestIndex, 4),
                    v: v > 0.1 ? utility.num.frac(v, 4) : v
                };
                if ([tsdata.d, tsdata.s, tsdata.e, tsdata.h, tsdata.l, tsdata.v].some(r => !normalNum(r, false)))
                    throw new Error(`bad value: ${JSON.stringify(tsdata)}`);
                if (prevdts != null) {
                    const prevData = vmap[prevdts];
                    if (prevData.s === tsdata.s && prevData.e === tsdata.e && prevData.h === tsdata.h && prevData.l === tsdata.l)
                        throw new Error(`exactly same data in ${utility.date.dateFormat(utility.date.dateTs2MsTs(prevdts))} and ${utility.date.dateFormat(utility.date.dateTs2MsTs(dayts))}`);
                }
                vmap[dayts] = tsdata;
                prevdts = dayts;
            }
            const maxdayts = utility.date.msTs2DateTs(parseDateStr(data[data.length - 1].tradeDate));
            const mindayts = utility.date.msTs2DateTs(parseDateStr(data[0].tradeDate));
            return quickview(vmap, null, mindayts, maxdayts);
        });
}

function resolveStock(pack: WmRawRefinedInput): bb<WmRawOutput> {
    return bb.resolve()
        .then(() => datasrc.wm.market.getMktEqud(new datasrc.wm.GetMktEqudParams(pack.target, pack.start, pack.end, stockFields)))
        .then(data => {
            data = data.filter(d => d.isOpen === 1);
            if (data.length === 0) return { nodata: true };
            let prevdts: number = null;
            const fdAccm = data[0].accumAdjFactor, vmap: { [key: number]: dailyStockData } = {};
            for (let d of data) {
                const ratio = d.accumAdjFactor / fdAccm;
                if (!normalNum(ratio, false)) throw new Error(`bad ratio: ${ratio}`);
                const dayts = utility.date.msTs2DateTs(parseDateStr(d.tradeDate));
                if (prevdts != null && dayts <= prevdts) throw new Error(`data not sorted by tradeDate: ${utility.date.dateFormat(utility.date.dateTs2MsTs(prevdts))} - ${utility.date.dateFormat(utility.date.dateTs2MsTs(dayts))}`);
                const v = d.turnoverValue / 100000000;
                const tsdata: dailyStockData = {
                    d: dayts,
                    s: utility.num.frac(d.openPrice * ratio, 4),
                    e: utility.num.frac(d.closePrice * ratio, 4),
                    h: utility.num.frac(d.highestPrice * ratio, 4),
                    l: utility.num.frac(d.lowestPrice * ratio, 4),
                    ex: d.turnoverRate,
                    v: v < 0.1 ? v : utility.num.frac(v, 4),
                    mv: utility.num.frac(d.marketValue / 100000000, 4),
                    nr: utility.num.frac(d.negMarketValue / d.marketValue, 4)
                };
                // if (dayts === 16924 && pack.target === '300277.XSHE')
                //     tsdata.ex = 0.067;
                // else if (dayts === 16925 && pack.target === '300277.XSHE')
                //     tsdata.ex = 0.0567;
                // else if (dayts ===  16926&& pack.target === '300277.XSHE')
                //     tsdata.ex = 0.0655;
                if (!normalNum(tsdata.ex, true) || tsdata.ex > 1 || tsdata.nr > 1 || [
                    tsdata.d, tsdata.s, tsdata.e, tsdata.h, tsdata.l, tsdata.v, tsdata.mv, tsdata.nr
                ].some(r => !normalNum(r, false))) throw new Error(`bad value: ${JSON.stringify(tsdata)}`);
                if (prevdts != null) {
                    const prevData = vmap[prevdts];
                    if (prevData.s === tsdata.s && prevData.e === tsdata.e && prevData.h === tsdata.h && prevData.l === tsdata.l)
                        throw new Error(`exactly same data in ${utility.date.dateFormat(utility.date.dateTs2MsTs(prevdts))} and ${utility.date.dateFormat(utility.date.dateTs2MsTs(dayts))}`);
                }
                vmap[dayts] = tsdata;
                prevdts = dayts;
            }
            const maxdayts = utility.date.msTs2DateTs(parseDateStr(data[data.length - 1].tradeDate));
            const mindayts = utility.date.msTs2DateTs(parseDateStr(data[0].tradeDate));
            return quickview(vmap, data[0].preClosePrice, mindayts, maxdayts);
        });
}

function quickview(vmap: { [key: number]: dailyStockData }, prevend: number, minDayTs: number, maxDayTs: number): bb<WmRawOutput> {
    return bb.resolve()
        .then(() => {
            if (prevend != null) vmap[minDayTs].p = prevend;
            const findata: WmRawOutput_data = {
                maxDayTs: maxDayTs,
                minDayTs: minDayTs,
                data: vmap
            };
            if ((maxDayTs - minDayTs) > 30) {
                return filestorage.azure.upload(new Buffer(JSON.stringify(findata)), utility.randomStr() + '.json', null, config.azurestorage.container.temp)
                    .then(drop => { return <WmRawOutput>{ nodata: false, drop: drop } });
            }
            else return <WmRawOutput>{
                nodata: false,
                rawdata: findata
            }
        });
}

// 2015-12-05 -> utc timestamp
function parseDateStr(datestr: string): number {
    if (datestr.length !== 10 || datestr[4] !== '-' || datestr[7] !== '-') throw new Error(`bad format of date string: ${datestr}`);
    return Date.UTC(Number(datestr.slice(0, 4)), Number(datestr.slice(5, 7)) - 1, Number(datestr.slice(8)));
}

function normalNum(num: any, allowzero: boolean) {
    return utility.validate.isNum(num) && !isNaN(num) && isFinite(num) && (allowzero ? (num >= 0) : (num > 0));
};
